## 一. Linux目录结构与常用命令

### 1. 目录结构与文件

Linux只有一个根目录`/`，

![struct](E:\Linux-learn\struct.png)

### 2. 基础命令格式

命令行：命令提示符页面，只能处理字符串(文本)，以纯“字符串”的形式操作系统，用各种字符化的命令对系统发出操作指令，其本身也是一个程序。

命令：即Linux程序

>Linux命令解释程序的工作流程如下：
>
>1. 用户输入命令：用户在终端窗口中输入需要执行的命令，例如”ls”。
>2. Shell解释命令：用户输入的命令首先被Shell解释。Shell是一种命令行解释器，负责解析并执行用户输入的命令。它会将命令分解成命令名和参数，以及执行命令所需的其他信息。
>3. 执行命令：Shell根据用户输入的命令名，在系统中找到对应的可执行程序。如果找到了对应的程序，Shell会创建一个子进程，并使用exec系统调用来执行该程序。如果命令是一个内置命令，Shell则直接执行该命令。
>4. 程序执行：子进程获得了命令的控制权后，会将命令所需的参数和其他信息传递给相应的程序。程序开始执行，并根据命令的功能进行相关操作。执行过程中，程序可能会读取文件、修改系统状态、向终端输出信息等。
>5. 程序结束：当程序执行完毕或遇到错误时，会返回执行结果或错误信息。Shell会接收到程序的返回值，并将其显示给用户。
>6. Shell等待下一条命令：程序执行完毕后，Shell会等待用户输入下一条命令，循环执行上述步骤。
>
>总结来说，Linux命令解释程序的工作流程包括用户输入命令、Shell解释命令、执行命令、程序执行以及Shell等待下一条命令。通过这个流程，用户可以通过命令行界面与系统交互，并完成各种操作。

==通用格式：==

`command [-options] [parameter]`

- command：命令本身

- -options：[可选]命令的一些选项/标识符，可以通过选项控制命令的行为细节或指定特定的操作

  `-` 单横线选项后面跟的参数必须是单字符参数，一个字符表示一个参数，可以多个参数写在同一个横线后面

  `--` 双横线选项后面跟的参数必须是多字符参数（单词），双横线后只能跟一个参数。

- parame：[可选]命令的参数，多数用于命令的指向目标等

  在需要加参数且为多个参数的时候，参数可以使用“=”分隔，也可以使用空格分隔。

==使用终端的常用技巧：==

**放大终端窗口字体**：`ctrl + shift + =`<br>**缩小终端窗口字体**：`ctrl + -`

**查阅命令帮助信息**：	两个选项

```shell
command --help
#显示command命令的帮助信息
man command
#查阅command命令的使用手册manual
```

使用`man`（手册形式展示文件内容）时的操作键：

| 空格键 | 显示手册页的下一页   |
| :----- | :------------------- |
| Enter  | 一次滚动手册页的一行 |
| b      | 回滚一屏             |
| f      | 前滚一屏             |
| q      | 退出                 |
| /word  | 搜索"word"字符串     |



输入clear或使用快捷键`ctrl + L` ，可以实现**清屏**

直接输入文件的名字（文件路径）作为命令，若该文件是可执行程序，相当于直接**执行该程序**

**强制终止程序运行**：`ctrl + C`

**自动补全**：在敲出命令的前几个字母后，按下`Tab` 键

- 如果输入的没有歧义，终端会自动补全
- 如果有歧义，再按一下`Tab` ，终端会打印出可能存在的命令

**追溯曾经使用过的命令**：

- 按`上 / 下`光标键可以在曾经使用过的命令之间进行切换
- 若要退出选择并且不想执行当前选中的命令，按`ctlr + C`

---



### 3. 文件和目录相关命令

- 文件路径表示相关

​        绝对路径：以根目录为起点，路径描述以`/`开头

​	相对路径：以当前目录为起点，路径描述无需以`/`开头

​	特殊路径符：

- .  表示当前目录
- ..  表示上一级目录
- ~  表示用户的home目录

**本质上讲，linux每个文件的名字就是其路径，文件名=文件路径，只是我们起名或说一个文件的名字时，常忽略前面的路径，只说文件自身的名字**

- 查看目录内容

  ```shell
  # ls:list,列出目录的内容
  ls [-a -l -h] [文件路径]
  # -a:all，列出全部文件
  # -l:列表（竖向排列）形式展示内容，并展示更多信息
  # -h:使用 -lh，显示文件的大小单位
  # 参数默认为当前所在工作目录
  ```

- 切换工作目录

```shell
# cd: Change Directory,更改当前所在的工作目录
cd [文件路径]
# 参数默认为回到用户的home目录
```

- 查看当前工作目录路径

```shell
# pwd: Print Work Directory
pwd
```

- 创建新的目录(文件夹)

```shell
# mkdir: Make Directory
mkdir [-p] 文件路径
# -p: 表示自动创建不存在的父目录，适用于创建连续多层级的目录
# 参数必填，表示要创建的文件夹的路径，相对或绝对表示方法均可
```

- 创建新的文件

```shell
# touch
touch 文件路径
# 参数必填，表示要创建的文件的路径
```

- 拷贝文件 / 文件夹（目录文件）

```shell
# cp: copy, 复制文件/文件夹
cp [-r] 参数1 参数2
# -r: 可选，用于复制文件夹，表示递归
# 参数1: 文件路径，表示被复制的文件或文件夹
# 参数2: 文件路径，表示要复制去的地方，若为文件夹，则复制到文件夹内或复制并重命名文件夹；若为文件，则复制并重命名文件
```

- 移动文件 / 文件夹（目录文件），为文件 / 文件夹（目录文件）改名

```shell
# mv: move, 移动文件/文件夹，为文件 / 文件夹改名
mv 参数1 参数2
# 参数1: 文件路径，表示被移动的文件或文件夹
# 参数2: 文件路径，表示要移动去的地方，若为文件夹，则移动到文件夹内或移动并重命名文件夹；若为文件，则移动并重命名文件
```



mv 参数设置与运行结果（cp也可参考此表）

| 命令格式                                         | 运行结果                                                     |
| :----------------------------------------------- | :----------------------------------------------------------- |
| `mv source_file(文件) dest_file(文件)`           | 将源文件名 source_file 改为目标文件名 dest_file              |
| `mv source_file(文件) dest_directory(目录)`      | 将文件 source_file 移动到目标目录 dest_directory 中          |
| `mv source_directory(目录) dest_directory(目录)` | 目录名 dest_directory 已存在，将 source_directory 移动到目录名 dest_directory 中；目录名 dest_directory 不存在则 source_directory 改名为目录名 dest_directory |
| `mv source_directory(目录) dest_file(文件)`      | 出错                                                         |



- 删除文件 / 文件夹（目录文件）

```shell
# rm: remove, 删除文件/文件夹
rm [-r -f] 参数
# -r: 可选，用于删除文件夹，表示递归
# -f: 可选，强制删除，不弹出提示（root超级管理员用户）
# 参数: 表示要删除的文件或文件夹的路径
```

删除当前目录下的所有文件及目录，命令行为：

```shell
rm  -rf  * 
```

文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。



- 查找命令对应的程序文件位置

```shell
# Linux命令的本体就是一个个二进制可执行程序，我们可以通过which命令，查找所使用的一系列命令的程序文件存放在哪里
which 要查找的命令
```



- 在指定目录下查找匹配的文件和目录

```shell
# find: 在指定目录下查找特定匹配的文件和目录，它可以使用不同的选项来过滤和限制查找的结果
find [文件路径] [匹配条件] [动作]
# 路径 是要查找的目录路径，可以是一个目录或文件名，也可以是多个路径，多个路径之间用空格分隔，如果未指定路径，则默认为当前目录。
# 匹配条件 是可选参数，用于指定查找的条件，可以是文件名、文件类型、文件大小等等。
# 动作 可选的，用于对匹配到的文件执行操作，比如删除、复制等。
```



匹配条件 中可使用的选项有二三十个之多，以下列出最常用的部份：

- `-name pattern`：按文件名查找，文件名`pattern`支持使用通配符 `*` 和 `?`。

- `-type type`：按文件类型查找，可以是 `f`（普通文件）、`d`（目录）、`l`（符号链接）等。

- `-size [+-]size[cwbkMG]`：按文件大小查找，支持使用 `+` 或 `-` 表示大于或小于指定大小，单位可以是 `c`（字节）、`w`（字数）、`b`（块数）、`k`（KB）、`M`（MB）或 `G`（GB）。

- `-mtime days`：按修改时间查找，支持使用 `+` 或 `-` 表示在指定天数前或后，days 是一个整数表示天数。

- `-user username`：按文件所有者查找。

- `-group groupname`：按文件所属组查找。

  

### 5. 文件内容读写相关命令

**Linux系统下任何文件的读写是按文本文件进行处理**

- 查看文件内容

```shell
# cat: 直接将内容全部显示在终端
cat [-b -n] 文件路径
-b: 对非空输出行编号
-n: 对所有输出行编号

# more: 支持翻页，若文件内容过多可以一页页的展示(手册形式)
more 文件路径
```

- 在文件中进行文本搜索，模式查找

```shell
# grep: 通过正则表达式过滤文件行，实现模式查找/文本搜索
grep [-n -i] "正则表达式" 文件路径
# -n: 显示匹配行的行号
# -i: 忽略大小写
# 正则表达式 : ^a(搜索以a开头的行), ke$(搜索以ke结束的行)
# 文件路径: 必填，可使用管道符作为输入
```

- 统计文件的行数、单词数量、字节数

```shell
# wc: 统计文件的行数、单词数量、字节数
wc [-c -m -l -w] 文件路径
# -c: 统计bytes的数量
# -m: 统计字符的数量
# -l: 统计行数
# -w: 统计单词数量
# 文件路径: 必填，可使用管道符作为输入
```



### 6. 输入输出流相关命令

- **管道符 `|`** : 将一个命令的输出通过管道作为另一个命令的输入
- **echo命令**：在命令行输出指定字符串内容

```shell
echo 输出的内容
# 无需选项，只有一个参数，表示要输出的字符串，复杂内容可用" "包围
echo `pwd`
# 将命令用反引号包围，被反引号包围的内容不再作为普通字符串直接输出，而是会先被作为命令执行，再将结果输出到命令行
```

- **重定向符**: 执行命令的结果（如echo命令），若不想默认输出到终端命令行，可使用重定向符号写入文件
  - `>` : 将左侧命令的结果，覆盖写入到符号右侧文件
  - `>>` : 将左侧命令的结果，追加写入到符号右侧文件

- **tail命令**: 查看文件尾部内容，跟踪文件的最新更改

```shell
tail [-f -num] 文件路径
# -f: 表示持续跟踪，即监听功能
# -num: 具体数字，表示查看尾部 num 行，不填则默认10行
# 文件路径: 必填
```



## 二. 用户管理与权限

操作系统采用多用户的管理模式进行权限管理

- 在Linux系统中，拥有最大权限的账户为`root`（超级管理员）

- 一般使用电脑者使用自创账户，即普通用户权限

  - 普通用户一般在`home`目录内不受限
  - 离开``home`目录，大多数地方普通用户仅有只读和执行的权限，无修改权限

- 这种模式这是由于早年计算机还未充分个人化，多人使用同一台计算机设备而产生的解决方案

  

**切换账户 : `su` 命令**

```shell
# su : Switch User
su [-] [用户名]
# -符号: 可选，表示是否在切换用户后加载环境变量，建议带上
# 用户名: 可选，表示要切换的用户，若省略表示切换到root（已知root账户密码的情况下）
# 切换用户后，可以使用exit命令退回上一个用户，也可以使用快捷键："ctrl + d"
# 使用普通用户切换到其他用户需要使用密码；使用root用户切换到其他用户，无需密码，直接切换
```



>#### 在Ubuntu中切换用户的方法
>
>在Ubuntu操作系统中，用户可以通过多种方式在不同用户之间切换。这对于需要执行特定权限操作的情况非常有用，例如访问受限文件或执行系统级命令。
>
>**使用命令行切换用户**
>
>在命令行环境中，可以使用*su*（switch user）命令来切换用户。如果你想从当前用户切换到root用户，可以使用以下命令：
>
>```shell
>sudo su
>```
>
>这个命令会将你的用户切换到root用户，这通常需要root权限。**由于Ubuntu默认情况下root用户没有固定密码，因此直接使用*su*命令可能不会成功，因为你不知道root的密码。**
>
>在切换到root用户后，如果想要切回到普通用户，可以使用以下命令：
>
>```shell
>su -l 用户名
>```
>
>或者简单地使用*exit*命令或*Ctrl+D*快捷键退出当前root会话。
>
>**设置root用户密码**
>
>如果你需要为root用户设置一个固定密码，可以执行以下命令：
>
>```shell
>sudo passwd root
>```
>
>
>
>按照提示操作，设置一个新的root密码。设置密码后，你可以直接使用*su root*命令并输入密码来切换到root用户。
>
>**禁用和启用root登录**
>
>如果你想禁用root用户的登录，可以使用以下命令：
>
>```shell
>sudo passwd -l root
>```
>
>
>
>这个命令只是禁用root用户，但密码仍然会被保存。如果你想重新启用root用户的登录，可以执行：
>
>```shell
>sudo passwd -u root
>```
>
>



**授权（相当于windows下以管理员身份运行）: `sudo`命令**

```shell
# 长期使用root用户，可能会在不经意时造成系统损坏，使用sudo命令，为普通的命令授权，临时以root身份运行
sudo 其他命令
# 不是所有用户都有权使用sudo命令获取特权，我们需要为普通用户配置sudo认证
```

>#### 为普通用户配置sudo认证
>
>切换到`root`用户，执行`vim sudo` ，打开vim编辑器在文件的最后添加：
>
>```shell
>用户名 ALL=(ALL)	NOPASSWD:ALL
># 其中NOPASSWD:ALL 表示使用sudo命令时，无需输入密码
>```
>
>`wq`保存并退出
>
>然后切换会普通用户即可执行sudo



**用户和用户组：**

Linux系统中可以

- 配置多个用户
- 配置多个用户组
- 一个用户可以加入多个用户组

相应的，LInux中关于权限的管控有两个级别

- 针对用户的权限控制
- 针对用户组的权限控制

比如，针对某文件，可以控制用户对其的权限，也可以控制用户组对其的权限



==以下命令中的创建/删除命令需root用户执行，因此要么切换到root用户，要么使用sudo授权==

**用户组管理：**

- 创建用户组

```shell
groupadd 用户组名
```

- 删除用户组

```shell
groupdel 用户组名
```

- 查看组信息

```shell
# 组信息保存在/etc/group 文件中，/etc目录是专门用来保存系统配置信息的目录
cat /etc/group
```

>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。
>
>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。
>
>当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。
>
>用户组的所有信息都存放在/etc/group文件中，由冒号(:)隔开若干个字段，这些字段有：
>
>```
>组名:口令:组标识号:组内用户列表
>```
>
>1. "组名" 是用户组的名称，由字母或数字构成。组名不应重复。
>2. "密码" 字段存放的是用户组加密后的密码。一般Linux 系统的用户组都没有密码，即这个字段一般为空，或者是*。
>3. "组标识号（GID）" 与用户标识号类似，也是一个整数，被系统内部用来标识组。
>4. "组内用户列表" 是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。

- 修改用户组的属性

```shell
groupmod 选项 用户组
# 常用的选项有：
# -g GID :为用户组指定新的组标识号。
# n新用户组 :将用户组的名字改为新名字
```





**用户管理：**

- 创建用户 & 设置/修改密码

```shell
useradd [-g -d] 用户名
# -g: 指定用户所属的组，指定-g需要组已经存在，如果已存在与用户名同名的组，则必须使用-g; 不指定-g则会创建与用户名同名的组并自动加入
# -d: 指定用户的home路径，不指定，home目录默认在：/home/用户名
passwd 用户名
# 普通用户可直接用passwd修改自己的账户密码
```

- 删除用户

```shell
userdel [-r] 用户名
# -r: 删除用户的home目录; 不使用-r，删除用户时会将home目录保留
```

- 查看用户信息

```shell
# 用户信息保存在/etc/passwd 文件中
cat /etc/passwd | grep 用户名
或
getent passwd   #等价于 cat /etc/passwd

# 只想查看用户所属组
id [用户名]
# 用户名: 若不提供，则查看自身

who
# 查看当前所有登录操作系统的用户列表
whoami
# 查看当前登录用户的用户名
```

>passwd文件由6个冒号组成7个字段，
>
>```shell
>用户名:口令:用户标识号:主组标识号:注释性描述:主目录:登录Shell
>```
>
>具体含义如下：
>
>1. “用户名”
>2. “密码”一般为x，表示加密的密码
>3. “用户标识号（UID）” 一个整数，系统内部用它来标识用户
>4. “主组标识号（GID）”
>5. “注释性描述” 字段记录着用户的一些个人情况
>6. “主目录” home目录位置
>7. “登录shell” 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell
>
>>**系统中有一类用户称为伪用户（pseudo users）**
>>
>>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。
>>
>>常见的伪用户如下所示：
>>
>>```
>>伪 用 户 含 义 
>>bin 拥有可执行的用户命令文件 
>>sys 拥有系统文件 
>>adm 拥有帐户文件 
>>uucp UUCP使用 
>>lp lp或lpd子系统使用 
>>nobody NFS使用
>>```



- 修改用户账号的属性

`usermod` 命令可以用来设置用户的 主组/附加组 和 登录shell，

- 主组：通常在新建用户时指定，在`/etc/passwd`中GID对应的组即为主组
- 附加组：在`/etc/group`中最后一列表示该组是这一列中用户的附加组，或`id`命令后得到的`组=`中的非GID组即为该用户的附加组，用于指定用户的附加权限

```shell
# 修改用户的主组
usermod -g 用户组名 用户名
# 修改用户的附加组
usermod -G 用户组名 用户名
# 修改用户的登录shell
usermod -s /bin/bash
# 修改用户账号名称
usermod -l 新用户名 原用户名
# 修改用户uid
usermod -u <uid> 原用户名
# 解除密码绑定
usermod -U 用户名
```

>默认使用`useradd`添加的用户没有权限使用sudo获取特权，这里我们除了在root用户下修改文件，还可以用另一种方法，即将用户添加到sudo附加组中
>
>```shell
>usermod -G sudo 用户名
>```



**查看和管理用户权限控制：**

为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。

在 Linux 中我们可以使用 **ll** 或者 **ls –l** 命令来显示一个文件的属性以及文件所属的用户和组，如：

```
[root@www /]# ls -l
total 64
dr-xr-xr-x   2 root root 4096 Dec 14  2012 bin
dr-xr-xr-x   4 mysql mysql 4096 Apr 19  2012 boot
……
```

实例中，**bin** 文件的第一个属性用 **d** 表示。**d** 在 Linux 中代表该文件是一个目录文件。

在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。

- 当为 **d** 则是目录
- 当为 **-** 则是文件；
- 若是 **l** 则表示为链接文档(link file)；
- 若是 **b** 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；
- 若是 **c** 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。



---

接下来的字符中，以三个为一组，且均为 **rwx** 的三个参数的组合。其中， **r** 代表可读(read)、 **w** 代表可写(write)、 **x** 代表可作为程序执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 **-** 而已。

![](https://www.runoob.com/wp-content/uploads/2014/06/363003_1227493859FdXT.png)

从左至右用 **0-9** 这些数字来表示。

第 **0** 位确定文件类型，第 **1-3** 位确定属主（该文件的所有者）拥有该文件的权限。

第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。

其中，第 **1、4、7** 位表示读权限，如果用 **r** 字符表示，则有读权限，如果用 **-** 字符表示，则没有读权限；

第 **2、5、8** 位表示写权限，如果用 **w** 字符表示，则有写权限，如果用 **-** 字符表示没有写权限；第 **3、6、9** 位表示可执行权限，如果用 **x** 字符表示，则有执行权限，如果用 **-** 字符表示，则没有执行权限。

>针对目录文件（文件夹）
>
>- r：可以查看文件夹内容，如ls命令
>
>- w：可以在文件夹内创建、删除、改名等
>
>- x：可以更改工作目录到此文件夹，如cd命令



---

对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。

同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。

文件所有者以外的用户又可以分为文件所属主组的同组用户和其他用户。

因此，Linux系统按文件所有者（属主）、文件所有者同组用户（属组）和其他用户来规定了不同的文件访问权限。

在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。

对于 root 用户来说，一般情况下，文件的权限对其不起作用。



---

**更改文件属性：**

**chown命令：更改文件所有者（owner），也可以同时更改文件所属组**

```shell
chown [–R] 所有者 文件名
chown [-R] 所有者:属组名 文件名
# -R: 递归更改文件属组，就是在更改某个目录文件的属组时，如果加上 -R 的参数，那么该目录下的所有文件的属组都会更改。
```



**chmod：更改文件9个属性**

Linux 文件的基本权限就有九个，分别是 **owner/group/others(拥有者/组/其他)** 三种身份各有自己的 **read/write/execute** 权限。

先复习一下刚刚上面提到的数据：文件的权限字符为： **-rwxrwxrwx** ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：

- r:4
- w:2
- x:1

每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如要设置权限为： **-rwxrwx---** 分数则是：

- owner = rwx = 4+2+1 = 7
- group = rwx = 4+2+1 = 7
- others= --- = 0+0+0 = 0

所以等一下我们设定权限的变更时，该文件的权限数字就是 **770**。变更权限的指令 chmod 的语法是这样的：

```shell
 chmod [-R] xyz 文件或目录
 # xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。
 # R : 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更
```
